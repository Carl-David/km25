---
import Icon from './Icon.astro';
// TODO: 5 is not the amount outputted though, change logic in loop?
const milestoneCount = 5;
const milestoneSvg = `<image
    data-milestone2
    href="/images/icons/flag.svg"
    height="50"
    width="50"
    y="-44"
  />`.repeat(milestoneCount);
---

<div class="flex flex-row justify-center gap-2">
  <div
    class="self-center text-gray-400 dark:text-gray-300 uppercase font-[Impact] mb-4"
  >
    <Icon type="Sweden" />
  </div>
  <div class="w-full my-12">
    <div class="relative">
      <div
        data-bike
        class="absolute top-[-27px] bg-white dark:bg-gray-800 confetti"
      >
        <Icon type="Bike" showName={false} />
      </div>
      {
        [...Array(milestoneCount)].map(
          (_, i) =>
            i > 0 &&
            i < milestoneCount && (
              <div
                data-milestone={(i * 100) / milestoneCount}
                class="transition duration-500 opacity-0"
              >
                <Icon
                  type="Flag"
                  showName={false}
                  classList={[`absolute top-[-15px]`]}
                  style={`left: calc(${(i * 100) / milestoneCount}%)`}
                />
              </div>
            )
        )
      }
      <div
        data-track
        class="w-full border-b border-1 border-dashed border-stone-300"
      >
      </div>
    </div>
  </div>
  <div
    class="self-center text-gray-400 dark:text-gray-300 uppercase font-[Impact]"
  >
    <!-- TODO: 
      SVG Path animate on scroll: https://stackoverflow.com/questions/50910459/how-to-animate-element-along-svg-path-on-scroll -->
    <Icon type="South Africa" />
  </div>
</div>
<!-- TODO: Loop at the bottom so bike spins, with upside-down checkpoint? Or just do a diagonal line above SE and below SA? -->
<div class="wrapper">
  <div class="container">
    <svg
      width="100%"
      height="164%"
      viewBox="0 0 2000 2000"
      preserveAspectRatio="none"
      set:html={milestoneSvg}
    >
      <!-- TODO: Left and right with %-width, fixed in beginning. Or needs to be same path? Or can a paths ends be expressed with %? -->
      <!-- TODO: https://codepen.io/gionkunz/pen/RwaWgB -->
      <path
        id="path1"
        d="M 20 1000 C 1000 500 1000 500 2000 1000"
        style="fill:none;stroke:rgb(214,211,209);stroke-width:2;stroke-dasharray:15"
      ></path>
      <image
        id="bike"
        href="/images/icons/bike.svg"
        height="6%"
        width="6%"
        y="-84"
      />
    </svg>
  </div>
</div>
<style>
  @keyframes confetti {
    from {
      transform: translate3d(0, 0, 0);
      opacity: 1;
    }
  }

  /* TODO: Tailwind */
  .wrapper {
    width: 100%;
    margin: 0 auto;

    .container {
      position: relative;
      height: 0;
      padding-bottom: 56.25%;

      > svg {
        position: absolute;
        display: block;

        path {
          stroke: red;
          stroke-width: 10px;
          stroke-linejoin: round;
          stroke-linecap: round;
          stroke-dasharray: 1px, 15px;
          fill: green;
        }
      }
    }
  }
</style>

<script is:inline define:vars={{ milestoneCount }}>
  const bike = document.querySelector('[data-bike]');
  const track = document.querySelector('[data-track]');
  const milestones = document.querySelectorAll('[data-milestone]');
  let hasCelebrated = false;

  document.addEventListener('scroll', () => {
    // TODO: Split into more functions for readability, one handling bike, one handling confetti, one handling milestones etc
    const scrollPosition =
      1 - (track.getBoundingClientRect().y - 80) / (window.innerHeight - 120);
    const bikePercentageWidth = (32 / bike.parentElement.offsetWidth) * 100;
    const progress = Math.max(
      Math.min(100 - bikePercentageWidth, scrollPosition * 100),
      0
    );
    const isComplete = progress + bikePercentageWidth >= 100;
    bike
      .querySelector('img')
      .setAttribute(
        'title',
        progress >= 100 - bikePercentageWidth
          ? 'Done!'
          : `Only ${Math.round(100 - progress)}% left!`
      );
    bike.style.left = `${progress}%`;

    milestones.forEach((milestone) => {
      const value = milestone.getAttribute('data-milestone');

      if (value < progress + bikePercentageWidth) {
        milestone.classList.add('opacity-0');
      } else {
        milestone.classList.remove('opacity-0');
      }
    });

    if (isComplete && !hasCelebrated) {
      const confetti = document.createDocumentFragment();

      for (let i = 0; i < 50; i++) {
        const fragment = document.createElement('span');

        fragment.style.cssText =
          'animation: confetti 800ms ease-out forwards;' +
          'display: block;' +
          'position: absolute;' +
          'right: calc(50% - 3px);' +
          'top: 50%;' +
          'width: 3px;' +
          'height: 8px;' +
          'opacity: 0;' +
          'z-index: 50;' +
          'transform: translate3d(' +
          (Math.random() * 300 - 150) +
          'px, ' +
          (Math.random() * 200 - 100) +
          'px, 0) rotate(' +
          Math.random() * 360 +
          'deg); background: hsla(' +
          Math.random() * 360 +
          ',100%,50%,1);';

        confetti.appendChild(fragment);
      }

      bike.append(confetti);
      hasCelebrated = true;

      setTimeout(() => {
        bike.querySelectorAll('span').forEach((elem) => elem.remove());
      }, 800);
    } else if (!isComplete) {
      hasCelebrated = false;
    }
  });

  function positionCar() {
    const car = document.getElementById('bike');
    const milestones = document.querySelectorAll('[data-milestone2]');
    const path = document.getElementById('path1');
    // Calculate distance along the path the car should be for the current scroll amount
    const pathLen = path.getTotalLength();
    console.log({ pathLen });
    console.log('window.innerHeight', window.innerHeight);
    console.log(
      'car.getBoundingClientRect().y',
      path.getBoundingClientRect().y
    );
    const scrollPosition =
      1 - (path.getBoundingClientRect().y - 60) / (window.innerHeight - 120);

    console.log({ scrollPosition });

    const progress = Math.max(Math.min(100, scrollPosition * 100), 0);
    console.log({ progress });

    dist = Math.max(Math.min(pathLen, pathLen * scrollPosition), 0);
    console.log({ dist });

    const pos = path.getPointAtLength(dist);
    console.log({ pos });
    console.log('');

    // Calculate position a little ahead of the car (or behind if we are at the end), so we can calculate car angle
    let angle;

    if (dist + 1 <= pathLen) {
      const posAhead = path.getPointAtLength(dist + 1);
      angle = Math.atan2(posAhead.y - pos.y, posAhead.x - pos.x);
    } else {
      const posBehind = path.getPointAtLength(dist - 1);
      angle = Math.atan2(pos.y - posBehind.y, pos.x - posBehind.x);
    }
    // Position the car at "pos" totated by "angle"
    car.setAttribute(
      'transform',
      'translate(' + pos.x + ',' + pos.y + ') rotate(' + rad2deg(angle) + ')'
    );

    milestones.forEach((m, i) => {
      const milestoneDist = i * (pathLen / milestoneCount);
      const milestonePos = path.getPointAtLength(milestoneDist);

      const posAhead = path.getPointAtLength(milestoneDist + 1);
      const milestoneAngle = Math.atan2(
        posAhead.y - milestonePos.y,
        posAhead.x - milestonePos.x
      );

      m.setAttribute(
        'transform',
        'translate(' +
          milestonePos.x +
          ',' +
          milestonePos.y +
          ') rotate(' +
          rad2deg(milestoneAngle) +
          ')'
      );
    });
  }

  function rad2deg(rad) {
    return (180 * rad) / Math.PI;
  }

  // Reposition car whenever there is a scroll event
  window.addEventListener('scroll', positionCar);

  // Position the car initially
  positionCar();
</script>
